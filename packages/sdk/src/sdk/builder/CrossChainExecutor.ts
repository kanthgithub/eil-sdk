import { Hex, PrivateKeyAccount } from 'viem'

import {
  BatchStatusInfo,
  InternalVoucherInfo,
  OperationStatus,
  SdkVoucherRequest,
  SingleChainBatch,
  UserOperation
} from '../types/index.js'
import { CrossChainBuilder } from './CrossChainBuilder.js'
import { InternalConfig } from './InternalConfig.js'
import { SessionData } from '../../contractTypes/SessionData.js'
import {
  abiEncodeVouchers,
  EventsPoller,
  IEventPoller,
  isSameAddress,
  recursiveDecodeErrorResult
} from '../../utils/index.js'
import { nowSeconds } from '../../utils/utils.js'
import { assert } from '../sdkUtils/SdkUtils.js'
import { VoucherRequest } from '../../contractTypes/VoucherRequest.js'
import { appendPaymasterSignature, getUserOpHash } from '../sdkUtils/index.js'

export enum CallbackType {
  // submitting a UserOperation for execution
  Executing = 'executing',
  // userOperation completed execution
  Done = 'done',
  // UserOperation execution reverted
  Failed = 'failed',
  // before executing: UserOperation is waiting for vouchers to be signed by previous UserOperations
  // (called after those previous UserOperations are executed and submitted their voucher requests)
  WaitingForVouchers = 'waitingForVouchers',
  // a voucher was signed by a provider. called just before "executing".
  VoucherIssued = 'voucherIssued'
}

/**
 *  the ExecCallback parameters passed on each step of execution
 */
export type ExecCallbackData = {
  index: number
  type: CallbackType
  /** the userOp that was generated for this batch */
  userOp: UserOperation
  userOpHash: Hex

  /**
   *  for waitingForVoucher and voucherSigned, the voucher ID(s)
   *  that we're waiting for (or got signed)
   */
  requestIds?: Hex[]

  /** after this batch is executed, this is the on-chain transaction */
  txHash?: Hex

  /** if a batch reverted on-chain, this is the revert reason */
  revertReason?: any

  /** List of input voucher requests required to execute this batch */
  inputVoucherRequests: SdkVoucherRequest[]

  /** List of outputs: vouchers that are generated by the execution of this batch */
  outVoucherRequests: SdkVoucherRequest[]
}

/**
 * a callback function called by "execute()" on each step of execution
 */
//callback for each UserOperation execution step
export type ExecCallback = (param: ExecCallbackData) => void;

type RequestAndId = {
  request: VoucherRequest
  requestId: Hex
}

//internal type in watchForUserOperationEvents
type CollectedType = {
  requests: RequestAndId[]
  revertReason?: string
}

/**
 * Takes the output of the {@link CrossChainBuilder} and executes every {@link UserOperation} across multiple chains.
 * Handles cross-chain voucher signing and verification.
 */
export class CrossChainExecutor {

  private eventTriggered = 0

  /** Array of event watchers that can be used to unwatch all events */
  private eventPollers: Array<IEventPoller> = []

  /**
   * Initialized by the {@link execute} function to track the status of UserOperations containing the batches.
   */
  private batchStatusInfos: BatchStatusInfo[] = []

  constructor (
    readonly builder: CrossChainBuilder,
    readonly config: InternalConfig,
    private readonly ephemeralSigner: PrivateKeyAccount,
    readonly batches: SingleChainBatch[],
    readonly timeoutSeconds = config.input.execTimeoutSeconds ?? 30,
  ) {}

  /**
   * Executes the output of the {@link CrossChainBuilder}.
   * Must be called after all UserOperations are signed.
   * @param callback - a callback function called on every state change of a userOperation
   * @throws {Error} If UserOperations are not signed before execution.
   * @throws {Error} If called more than once.
   */
  async execute (callback: ExecCallback): Promise<void> {
    assert(this.batchStatusInfos.length == 0, 'execute() already called')
    if (!this.batches.every(op => op.userOp.signature != null)) {
      throw new Error('All UserOperations must be signed')
    }

    this.batchStatusInfos = this.batches.map(
      (
        (opExec, index) => (
          {
            index,
            batch: opExec,
            status: OperationStatus.Pending,
            vouchers: new Map()
          }
        )
      )
    )

    await this.watchForVoucherSignedEvents(this.batchStatusInfos, callback)

    try {
      while (true) {
        // dumpVouchers(this, this.batchStatusInfos)

        if (
          this.batchStatusInfos.every(op =>
            op.status == OperationStatus.Done ||
            op.status == OperationStatus.Failed)
        ) {
          // all operations are either done or have already failed
          break
        }
        const opToExecute = await this.findOpReadyToExecute(this.batchStatusInfos)

        if (opToExecute == undefined) {
          await this.waitForEvents()
        } else {
          await this.executeSingleBatch(opToExecute, callback)
        }
      }
    } finally {
      this.stopEllEventPollers()
    }
  }

  private async findOpReadyToExecute (ops: BatchStatusInfo[]): Promise<BatchStatusInfo | undefined> {
    for (const op of ops) {
      if (op.status != 'pending') {
        continue
      }

      if (await this.isWaitingForVouchers(op)) {
        continue
      }
      return op
    }
  }

  /**
   * Handles the execution of a single pending operation.
   * If the UserOp status is final ("done" or "failed"), no action is taken.
   * @param batchStatusInfo - The batch status info for the operation
   * @param callback - Callback function for operation events
   * @private
   */
  private async executeSingleBatch (batchStatusInfo: BatchStatusInfo, callback: ExecCallback): Promise<void> {
    // check if we can execute
    if (await this.isWaitingForVouchers(batchStatusInfo)) {
      //todo: only call callback if all batches that trigger those vouchers are executed.
      // (or are at least "executing")
      // otherwise, this callback will be called too often.
      this.callCallback(CallbackType.WaitingForVouchers, callback, batchStatusInfo)
      return // cannot execute yet, waiting for vouchers
    }

    await this.updateVouchersInUserOp(batchStatusInfo)

    batchStatusInfo.status = OperationStatus.Executing
    this.callCallback(CallbackType.Executing, callback, batchStatusInfo)
    const { userOp } = batchStatusInfo.batch

    this.watchForUserOperationEvents(batchStatusInfo, callback)
    console.warn('sendUserOperation:')
    console.warn(userOp)
    this.builder.smartAccount.sendUserOperation(userOp as UserOperation)
      .catch(e => {
        console.error('Error executing UserOperation:', e)
        // Validation failure during sending.
        // This indicates a potential issue with the UserOperation.
        batchStatusInfo.status = OperationStatus.Failed
        batchStatusInfo.revertReason = e as any
        this.callCallback(CallbackType.Failed, callback, batchStatusInfo)
      })
    // UserOperation is submitted. Will be considered "done" only after inclusion in a block.
  }

  /**
   * Checks if the given operation is waiting for vouchers.
   * @param batchStatusInfo - The batch info to check.
   * @returns True if operation is waiting for any vouchers,
   *          False if all pending voucher requests have corresponding vouchers.
   */
  private async isWaitingForVouchers (batchStatusInfo: BatchStatusInfo): Promise<boolean> {
    for (const req of batchStatusInfo.batch.inputVoucherRequests) {
      const voucherInfo = this.builder.getVoucherInternalInfo(req)
      if (voucherInfo.signedVoucher == undefined) {
        return true
      }
    }
    return false
  }

  /**
   * Updates the {@link BatchStatusInfo} with all the vouchers collected for the cross-chain execution.
   */
  private async updateVouchersInUserOp (batchStatusInfo: BatchStatusInfo): Promise<void> {
    let sessionData: SessionData = {
      data: '0x',
      ephemeralSignature: '0x'
    }
    const vouchersReq = batchStatusInfo.batch.inputVoucherRequests.map(req => this.builder.getVoucherInternalInfo(req).signedVoucher!)
    if (vouchersReq.length == 0) {
      return
    }
    assert(vouchersReq.every(v => v != undefined), 'missing voucher signature')
    const hash = await this.config.paymasters.call(batchStatusInfo.batch.chainId, 'getHashForEphemeralSignature', [vouchersReq, sessionData])
    sessionData.ephemeralSignature = await this.ephemeralSigner.sign({ hash })
    const paymasterSignature: Hex = abiEncodeVouchers(vouchersReq, sessionData)
    const existingPaymasterData: Hex = batchStatusInfo.batch.userOp.paymasterData ?? '0x'
    batchStatusInfo.batch.userOp.paymasterData = appendPaymasterSignature(existingPaymasterData, paymasterSignature)
  }

  /**
   * Watches for VoucherSigned events for all operations across chains.
   * @param ops - Array of BatchStatusInfo to monitor.
   * @param callback - Callback function for operation events.
   */
  private async watchForVoucherSignedEvents (ops: BatchStatusInfo[], callback: ExecCallback): Promise<void> {
    // Start watching for the VoucherSigned events even before submitting the UserOperations
    for (const op of ops) {
      for (const req of op.batch.inputVoucherRequests) {
        const info = this.builder.getVoucherInternalInfo(req)
        //in happy flow, it is signed on the source chain (by lockUserDeposit).
        this.watchForVoucherSignedEvent(info, op, callback)
        //todo: add bumpy flow, where alternate provider signs on dest chain,
      }
    }
  }

  //call the callback function, prevent errors from breaking the execution flow.
  private callCallback (type: CallbackType, callback: ExecCallback, op: BatchStatusInfo, requestId?: Hex): void {
    let requestIds = op.requestIds
    if (requestId != null) {
      requestIds = [requestId]
    }

    try {
      callback({
        index: op.index,
        type,
        userOp: op.batch.userOp,
        userOpHash: op.batch.userOpHash,
        txHash: op.txHash,
        requestIds,
        revertReason: op.revertReason,
        /** List of input voucher requests required to execute this batch */
        inputVoucherRequests: op.batch.inputVoucherRequests,

        /** List of outputs: vouchers that are generated by the execution of this batch */
        outVoucherRequests: op.batch.outVoucherRequests
      })
    } catch (e) {
      console.error(`Error in callback: ${type}`, e)
    }
  }

  private watchForVoucherSignedEvent (info: InternalVoucherInfo, op: BatchStatusInfo, callback: ExecCallback): void {
    const chainId = info.sourceBatch.chainId
    assert(info.voucherRequest != null)
    // look up for voucher by sender/senderNonce, not by requestId
    const { sender, senderNonce } = info.voucherRequest.origination
    console.log(`watching VoucherIssued for ${sender}/${senderNonce} on chain ${chainId}`)
    const paymaster = this.config.paymasters.addressOn(chainId)
    const eventPoller = new EventsPoller({
      client: this.config.chains.on(chainId),
      abi: this.config.paymasters.abi,
      eventNames: ['VoucherIssued'],
      onLog: (log: any) => {
        if (log.address.toLowerCase() != paymaster.toLowerCase() || log.args.sender.toLowerCase() != sender.toLowerCase() || log.args.senderNonce != senderNonce) {
          // console.log(`voucherIssued: ${log.address}/${log.args.sender}/${log.args.senderNonce}\n   - not ${paymaster}/${sender}/${senderNonce} - ignored. `)
          //not our event. ignore.
          return
        }
        this.removeEventPoller(eventPoller)
        this.onVoucherIssuedEvent(log.args, info, callback, op)
      }
    })
    this.addEventPoller(eventPoller)
  }

  private watchForUserOperationEvents (op: BatchStatusInfo, callback: ExecCallback): void {
    // submitted userOp. consider it "done" only once it gets included.
    const { userOp, chainId } = op.batch
    const userOpHash = getUserOpHash(userOp as UserOperation)

    //collected values in events prior UserOperationEvent (which always appears last)
    const collected: CollectedType = {
      requests: []
    }

    const UserOperationEvent = 'UserOperationEvent'
    const UserOperationRevertReason = 'UserOperationRevertReason'
    const VoucherRequestCreated = 'VoucherRequestCreated'

    const eventPoller: IEventPoller = new EventsPoller({
      client: this.config.chains.on(chainId),
      abi: [
        ...this.config.entrypoints.abi,
        ...this.config.paymasters.abi
      ],
      eventNames: [
        UserOperationEvent,
        UserOperationRevertReason,
        VoucherRequestCreated],
      onLog: (log) => {
        if (log.eventName == VoucherRequestCreated && isSameAddress(log.args.sender, userOp.sender)) {
          collected.requests.push({ requestId: log.args.id, request: log.args.voucherRequest })
        }
        if (log.args.userOpHash != userOpHash) {
          return
        }
        this.removeEventPoller(eventPoller)
        if (log.eventName == UserOperationRevertReason) {
          collected.revertReason = recursiveDecodeErrorResult(log.args.revertReason)
        } else {
          this.onUserOperationEvent(log.transactionHash, log.args, callback, op,
            collected)
        }
      }
    })
    this.addEventPoller(eventPoller)
  }

  private onVoucherIssuedEvent (
    args: any,
    info: InternalVoucherInfo,
    callback: ExecCallback,
    op: BatchStatusInfo
  ): void {
    this.eventTriggered++

    const voucherInternalInfo: InternalVoucherInfo = this.builder.getVoucherInternalInfo(info.voucher)

    voucherInternalInfo.signedVoucher = args.voucher
    const requestId: any = args.id
    this.callCallback(CallbackType.VoucherIssued, callback, op, requestId)
  }

  private onUserOperationEvent (
    txHash: Hex,
    args: any,
    callback: ExecCallback,
    op: BatchStatusInfo,
    collected: CollectedType
  ): void {
    this.eventTriggered++
    op.revertReason = collected.revertReason

    if (txHash == null) throw new Error('unknown user opHash')
    op.txHash = txHash
    if (args.success === true) {
      this.callCallback(CallbackType.Done, callback, op)
      op.status = OperationStatus.Done

      // call callback for any UserOp waiting for vouchers of this userOp:
      for (const outReq of op.batch.outVoucherRequests) {
        for (const nextOp of this.batchStatusInfos!) {
          if (nextOp.batch.inputVoucherRequests.some(inReq => outReq == inReq)) {
            if (!nextOp.requestIds) nextOp.requestIds = []
            // add requestIds related to this dest chain:
            for (const req of collected.requests ?? []) {
              if (req.request.destination.chainId == nextOp.batch.chainId) {
                nextOp.requestIds.push(req.requestId)
              }
            }

            this.callCallback(CallbackType.WaitingForVouchers, callback, nextOp)
          }
        }
      }

    } else {
      // should trigger fallback actions
      op.status = OperationStatus.Failed
      this.callCallback(CallbackType.Failed, callback, op)
    }
  }

  /**
   * Wait for events before rechecking all operations.
   * The timeout is specified in the constructor.
   */
  private async waitForEvents (): Promise<void> {
    const counter = this.eventTriggered
    const timeout = nowSeconds() + this.timeoutSeconds
    // poor-man busy-waiting for async events
    while (nowSeconds() < timeout) {
      if (counter != this.eventTriggered) {
        return
      }
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    throw new Error('timeout: ' + this.timeoutSeconds)
  }

  // stop all active event pollers.
  private stopEllEventPollers (): void {
    this.eventPollers.forEach(poller => poller.stopEventPoller())
    this.eventPollers = []
  }

  // add an event poller to the list of active event pollers, so we can stop then all at the end.
  private addEventPoller (poller: IEventPoller) {
    this.eventPollers.push(poller)
  }

  // stop an event poller, and remove it from the pending list.
  private removeEventPoller (eventPoller: IEventPoller) {
    eventPoller.stopEventPoller()
    const index = this.eventPollers.indexOf(eventPoller)
    if (index !== -1) {
      this.eventPollers.splice(index, 1)
    }
  }
}
